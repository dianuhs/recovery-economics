
from __future__ import annotations

import argparse
import json
import pathlib
from datetime import datetime, timezone
from typing import Any, Dict, Optional, Tuple, List

import yaml

from .aws_pricing import get_default_pricing
from .model import RestoreInputs, estimate_restore

HISTORY_FILE = pathlib.Path("history.jsonl")


# ---------- Helpers ----------

def load_scenario(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def compute_downtime(
    total_time_hours: float,
    detection_lag_hours: float,
    rto_hours: Optional[float],
    cost_per_hour: Optional[float],
) -> Tuple[float, float, float]:
    """Return (rto_miss_hours, downtime_loss_usd, end_to_end_downtime_hours)."""
    end_to_end = total_time_hours + max(0.0, detection_lag_hours or 0.0)
    if rto_hours is None or cost_per_hour is None:
        return 0.0, 0.0, end_to_end
    miss = max(0.0, end_to_end - rto_hours)
    return miss, miss * cost_per_hour, end_to_end


def log_decision(record: Dict[str, Any]) -> None:
    try:
        with HISTORY_FILE.open("a", encoding="utf-8") as f:
            f.write(json.dumps(record) + "\n")
    except Exception:
        # Logging should never break the CLI
        pass


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="recovery-economics")

    # Normal one-off mode
    p.add_argument("--tier", choices=["glacier", "deep_archive"])
    p.add_argument("--size-gb", type=float)
    p.add_argument("--destination", choices=["internet", "intra_aws"])
    p.add_argument("--bandwidth-mbps", type=float)
    p.add_argument("--efficiency", type=float)
    p.add_argument("--rto-hours", type=float)
    p.add_argument("--downtime-cost-per-hour", type=float)
    p.add_argument("--detection-lag-hours", type=float)

    # Scenario mode
    p.add_argument("--scenario-file", type=str, help="Path to scenario YAML.")
    p.add_argument("--strategy", type=str, help="Strategy id inside scenario file.")
    p.add_argument(
        "--compare-strategies",
        action="store_true",
        help="Compare all strategies defined in the scenario file.",
    )

    return p


# ---------- Strategy evaluation helpers ----------

def _extract_parameters(params: Dict[str, Any]) -> Dict[str, Any]:
    rto_hours = (params.get("rto_minutes") or 0) / 60.0
    detection_lag_hours = (params.get("detection_delay_minutes") or 0) / 60.0
    cost_per_hour = (params.get("cost_per_minute_outage") or 0) * 60.0

    incident_freq = params.get("incident_frequency_per_year")
    horizon_years = params.get("planning_horizon_years")
    reg_prob = params.get("regulatory_penalty_probability", 0.0)
    reg_amount = params.get("regulatory_penalty_amount", 0.0)
    discount_rate = params.get("discount_rate_annual", 0.0)

    return {
        "rto_hours": float(rto_hours),
        "detection_lag_hours": float(detection_lag_hours),
        "cost_per_hour": float(cost_per_hour),
        "incident_frequency_per_year": incident_freq,
        "planning_horizon_years": horizon_years,
        "regulatory_penalty_probability": float(reg_prob),
        "regulatory_penalty_amount": float(reg_amount),
        "discount_rate_annual": float(discount_rate),
    }


def evaluate_strategy(
    scenario: Dict[str, Any],
    strategy_id: str,
) -> Dict[str, Any]:
    params = scenario.get("parameters", {})
    strategies = scenario.get("strategies", {})
    if strategy_id not in strategies:
        raise SystemExit(f"Unknown strategy '{strategy_id}'")

    strat = strategies[strategy_id]
    restore = strat["restore"]

    tier = restore["tier"]
    size_gb = float(restore["size_gb"])
    destination = restore["destination"]
    bandwidth = float(restore["bandwidth_mbps"])
    efficiency = float(restore.get("efficiency", 0.7))

    derived = _extract_parameters(params)
    rto_hours = derived["rto_hours"]
    detection_lag_hours = derived["detection_lag_hours"]
    cost_per_hour = derived["cost_per_hour"]
    incident_freq = derived["incident_frequency_per_year"]
    horizon_years = derived["planning_horizon_years"]
    reg_prob = derived["regulatory_penalty_probability"]
    reg_amount = derived["regulatory_penalty_amount"]

    pricing = get_default_pricing(tier)
    inputs = RestoreInputs(
        data_size_gb=size_gb,
        bandwidth_mbps=bandwidth,
        link_efficiency=efficiency,
        restore_destination=destination,
        rto_hours=rto_hours,
    )
    result = estimate_restore(inputs, pricing)

    rto_miss, downtime_loss, end_to_end = compute_downtime(
        result.total_time_hours,
        detection_lag_hours,
        rto_hours,
        cost_per_hour,
    )

    # Regulatory penalty expected value per event
    expected_penalty_per_event = reg_prob * reg_amount if reg_prob and reg_amount else 0.0

    per_event_total_risk = downtime_loss + expected_penalty_per_event

    expected_over_horizon = None
    if incident_freq is not None and horizon_years is not None:
        expected_over_horizon = per_event_total_risk * incident_freq * horizon_years

    record: Dict[str, Any] = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "scenario": scenario.get("name"),
        "business_unit": scenario.get("business_unit"),
        "strategy": strategy_id,
        "tier": tier,
        "destination": destination,
        "size_gb": size_gb,
        "bandwidth_mbps": bandwidth,
        "efficiency": efficiency,
        "rto_hours": rto_hours,
        "detection_lag_hours": detection_lag_hours,
        "cost_per_hour": cost_per_hour,
        "total_time_hours": result.total_time_hours,
        "end_to_end_downtime_hours": end_to_end,
        "rto_miss_hours": rto_miss,
        "downtime_loss_per_event_usd": downtime_loss,
        "regulatory_penalty_expected_per_event_usd": expected_penalty_per_event,
        "total_risk_per_event_usd": per_event_total_risk,
        "incident_frequency_per_year": incident_freq,
        "planning_horizon_years": horizon_years,
        "expected_total_risk_over_horizon_usd": expected_over_horizon,
    }

    return record


def print_single_strategy(record: Dict[str, Any]) -> None:
    print("Recovery Economics — Scenario Mode")
    print("----------------------------------")
    print(f"Loaded scenario: {record.get('scenario')}")
    print(f"Business unit: {record.get('business_unit')}")

    print(f"\nStrategy: {record.get('strategy')}")
    print(f"Tier: {record.get('tier')} → {record.get('destination')}")
    print(f"Total restore time: {record['total_time_hours']:.2f}h")
    print(f"End-to-end downtime: {record['end_to_end_downtime_hours']:.2f}h")
    print(f"RTO: {record['rto_hours']:.2f}h")
    print(f"RTO miss: {record['rto_miss_hours']:.2f}h")

    print(
        f"Estimated downtime loss (per event): "
        f"${record['downtime_loss_per_event_usd']:,.2f}"
    )

    if record["regulatory_penalty_expected_per_event_usd"]:
        print(
            f"Expected regulatory penalty (per event): "
            f"${record['regulatory_penalty_expected_per_event_usd']:,.2f}"
        )

    if record["total_risk_per_event_usd"] != record["downtime_loss_per_event_usd"]:
        print(
            f"Total modeled risk (per event): "
            f"${record['total_risk_per_event_usd']:,.2f}"
        )

    if (
        record.get("incident_frequency_per_year") is not None
        and record.get("planning_horizon_years") is not None
        and record.get("expected_total_risk_over_horizon_usd") is not None
    ):
        print(
            f"Expected total risk over {record['planning_horizon_years']:.1f} years "
            f"at {record['incident_frequency_per_year']:.2f} incidents/year: "
            f"${record['expected_total_risk_over_horizon_usd']:,.2f}"
        )


def print_compare(records: List[Dict[str, Any]]) -> None:
    print("Recovery Economics — Scenario Strategy Comparison")
    print("-------------------------------------------------")
    if not records:
        print("No strategies to compare.")
        return

    scenario_name = records[0].get("scenario")
    bu = records[0].get("business_unit")
    print(f"Scenario: {scenario_name}")
    print(f"Business unit: {bu}\n")

    header = (
        f"{'Strategy':<14} {'Tier→Dest':<24} "
        f"{'E2E (h)':>8} {'RTO miss (h)':>12} "
        f"{'Downtime/evt':>15} {'Total risk/evt':>17} {'Exp risk horizon':>18}"
    )
    print(header)
    print("-" * len(header))

    for rec in records:
        tier_dest = f"{rec['tier']}→{rec['destination']}"
        downtime = rec['downtime_loss_per_event_usd']
        total_risk = rec['total_risk_per_event_usd']
        exp_horizon = rec.get('expected_total_risk_over_horizon_usd')

        exp_str = (
            f"${exp_horizon:,.0f}" if exp_horizon is not None else "n/a"
        )

        print(
            f"{rec['strategy']:<14} {tier_dest:<24} "
            f"{rec['end_to_end_downtime_hours']:>8.2f} {rec['rto_miss_hours']:>12.2f} "
            f"${downtime:>14,.0f} ${total_risk:>16,.0f} {exp_str:>18}"
        )


# ---------- Main ----------

def main() -> None:
    args = build_parser().parse_args()

    # Scenario-driven mode
    if args.scenario_file:
        scenario = load_scenario(args.scenario_file)
        strategies = scenario.get("strategies", {})

        # Compare all strategies
        if args.compare_strategies:
            records = [
                evaluate_strategy(scenario, sid)
                for sid in strategies.keys()
            ]
            print_compare(records)
            for rec in records:
                log_decision(rec)
            return

        # List strategies only
        if not args.strategy:
            print("Recovery Economics — Scenario Mode")
            print("----------------------------------")
            print(f"Loaded scenario: {scenario.get('name')}")
            print(f"Business unit: {scenario.get('business_unit')}")
            print("\nStrategies:")
            for k, v in strategies.items():
                print(f"- {k}: {v.get('description')}")
            print("\n[Scenario-only mode] No restore calculations run yet.")
            return

        # Single strategy evaluation
        record = evaluate_strategy(scenario, args.strategy)
        print_single_strategy(record)
        log_decision(record)
        return

    # Normal mode (backwards-compatible simple run)
    if args.tier is None or args.size_gb is None:
        raise SystemExit("Normal mode requires --tier and --size-gb when no scenario-file is given.")

    pricing = get_default_pricing(args.tier)
    inputs = RestoreInputs(
        data_size_gb=args.size_gb,
        bandwidth_mbps=args.bandwidth_mbps,
        link_efficiency=args.efficiency or 0.7,
        restore_destination=args.destination,
        rto_hours=args.rto_hours,
    )
    result = estimate_restore(inputs, pricing)
    print(f"Total restore time: {result.total_time_hours:.2f}h")


if __name__ == "__main__":
    main()
